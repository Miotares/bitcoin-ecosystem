<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta http-equiv="Content-Security-Policy" content="img-src 'self' data: https:;">

  <meta name="description"
    content="Entdecke das komplette Bitcoin-Ökosystem auf unserer interaktiven Karte. Finde Bitcoin-Services, Anbieter und Tools für Investitionen, Handel und mehr in Deutschland.">
  <meta name="keywords"
    content="Bitcoin Ecosystem, Bitcoin Deutschland, Bitcoin Karte, Bitcoin Services, Bitcoin Anbieter, Bitcoin Tools, Kryptowährung, Bitcoin Handel, Bitcoin Investition">
  <link rel="canonical" href="https://www.btc-eco.de/">

  <meta property="og:title" content="Bitcoin Ecosystem | Interaktive Karte des Bitcoin-Ökosystems">
  <meta property="og:description"
    content="Entdecke Bitcoin-Services, Anbieter und Tools auf unserer interaktiven Karte des Bitcoin-Ökosystems.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://www.btc-eco.de/">
  <meta property="og:image" content="https://www.bitcoin-ecosystem.de/images/bitcoin-ecosystem-og-image.jpg">
  <meta property="og:locale" content="de_DE">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Bitcoin Ecosystem | Interaktive Karte zu Bitcoin-Diensten">
  <meta name="twitter:description"
    content="Interaktive Karte des Bitcoin-Ökosystems mit Services, Anbietern und Tools für alle deine Bitcoin-Bedürfnisse.">
  <meta name="twitter:image" content="https://www.btc-eco.de/">

  <meta name="robots" content="index, follow">
  <meta name="language" content="German">
  <meta name="revisit-after" content="7 days">
  <meta name="author" content="Bitcoin Ecosystem Team">

  <script defer src="https://cloud.umami.is/script.js" data-website-id="4470f446-0407-4916-9dde-22e8d1566717"></script>

  <!-- Phosphor Icons -->
  <script src="https://unpkg.com/@phosphor-icons/web"></script>

  <link rel="stylesheet" href="style.css">
  <link rel="icon" type="image/x-icon" href="assets/logos/bitcoin.png">
  <title>Bitcoin Ecosystem | Interaktive Karte</title>
</head>

<body>
  <div class="container">
    <div class="search-container">
      <div class="search-input-wrapper">
        <i class="ph ph-magnifying-glass search-icon"></i>
        <input type="text" class="search-input" placeholder="Search ecosystem...">
      </div>
    </div>

    <div class="controls">
      <button class="control-button" id="zoom-in" aria-label="Zoom In"><i class="ph ph-plus"></i></button>
      <button class="control-button" id="zoom-out" aria-label="Zoom Out"><i class="ph ph-minus"></i></button>
      <button class="control-button" id="reset" aria-label="Reset View"><i
          class="ph ph-arrows-counter-clockwise"></i></button>
    </div>

    <div class="footer">
      Made with ❤️ by <a href="https://miotares.com" target="_blank">@miotares</a> &bull; <a
        href="https://miotares.com/impressum/" target="_blank">Impressum</a>
    </div>

    <svg id="bitcoin-ecosystem"></svg>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <script>
    // Dynamisches Laden der Services aus JSON und Rendering mit D3
    (async function () {
      const appBust = Date.now();
      const response = await fetch(`assets/services.json?v=${appBust}`);
      const data = await response.json();

      const svg = d3.select("#bitcoin-ecosystem");
      const width = window.innerWidth;
      const height = window.innerHeight;
      const g = svg.append("g");
      const defs = svg.append("defs");
      const cacheBust = Date.now();

      // Zoom
      const zoom = d3.zoom().scaleExtent([0.05, 3]).on("zoom", (event) => { g.attr("transform", event.transform); });
      svg.call(zoom);

      // Simulation - Obsidian Style
      const simulation = d3.forceSimulation()
        .velocityDecay(0.4) // Low friction for "floaty" feel
        .force("link", d3.forceLink().id(d => d.id).distance(d => {
          // Variable distances to create natural clusters
          if (d.source.id === 'shops') return 150;
          return d.source.depth === 0 ? 250 : d.source.depth === 1 ? 180 : d.source.depth === 2 ? 100 : 80;
        }).strength(0.5)) // Elastic links
        .force("charge", d3.forceManyBody().strength(d => {
          // Strong repulsion for main nodes, weaker for leaves to allow clustering
          return d.depth === 0 ? -4000 : d.depth === 1 ? -2500 : d.depth === 2 ? -1200 : -400;
        }))
        .force("center", d3.forceCenter(width / 2, height / 2).strength(0.05)) // Gentle gravity to center
        .force("collide", d3.forceCollide(d => {
          // Prevent overlap but allow close packing
          if (d.depth === 0) return 120;
          if (d.depth === 1) return 100;
          if (d.depth === 2) return 80;
          return 50;
        }).strength(0.7))
        .force("x", d3.forceX(width / 2).strength(0.02)) // Very weak centering force
        .force("y", d3.forceY(height / 2).strength(0.02))
        .alphaDecay(0.02); // Slow decay for long-running stabilization

      if (!data.image) { data.image = 'assets/logos/bitcoin.png'; }

      const serviceIndex = new Map();
      (function buildIndex(node) {
        if (!node || !node.children) return;
        for (const child of node.children) {
          if (child.children && child.children.length) {
            buildIndex(child);
          } else if (child.id) {
            serviceIndex.set(child.id, {
              id: child.id,
              name: child.name || '',
              link: child.link || '',
              image: child.image || '',
              description: child.description || '',
              region: child.region || '',
              promoCode: child.promoCode || '',
              promoDescription: child.promoDescription || '',
              isAffiliate: child.isAffiliate || false
            });
          }
        }
      })(data);

      const root = d3.hierarchy(data);
      const nodes = flatten(root);
      const links = root.links();

      function flatten(root) {
        const list = [];
        function walk(node, depth = 0) {
          if (node.children) node.children.forEach(child => walk(child, depth + 1));
          if (node.data && node.data.id) {
            const refId = node.data.ref;
            const aliased = refId ? serviceIndex.get(refId) : null;
            node.id = node.data.id; node.depth = depth;
            node.name = (node.data.name ?? aliased?.name) || "";
            node.link = (node.data.link ?? aliased?.link) || "";
            node.image = (node.data.image ?? aliased?.image) || "";
            node.description = (node.data.description ?? aliased?.description) || "";
            node.region = (node.data.region ?? aliased?.region) || "";
            node.promoCode = (node.data.promoCode ?? aliased?.promoCode) || "";
            node.promoDescription = (node.data.promoDescription ?? aliased?.promoDescription) || "";
            node.isAffiliate = (node.data.isAffiliate ?? aliased?.isAffiliate) || false;
            list.push(node);
          }
        }
        walk(root); return list;
      }

      nodes.forEach(d => { if (d.depth === 1 || d.depth === 2) { const textLength = d.name.length; const charWidth = 7; const padding = 24; const minWidth = 60; d.rectWidth = Math.max(minWidth, textLength * charWidth + padding); d.rectHeight = 44; } });

      const link = g.selectAll(".link").data(links).enter().append("line").attr("class", d => `link link-${d.source.id} link-${d.target.id}`);

      const node = g.selectAll(".node").data(nodes).enter().append("g").attr("class", d => `node depth-${d.depth}`).attr("id", d => `node-${d.id}`)
        .on("click", function (event, d) {
          if (d.children && d.children.length > 0) return;
          event.stopPropagation();
          openPopup(event, d);
        })
        .call(d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended));

      node.each(function (d) {
        const s = d3.select(this);
        if (d.depth === 0 || d.depth === 3) { const r = d.depth === 0 ? 50 : 30; s.append("circle").attr("r", r).attr("class", "node-shape"); }
        else { s.append("rect").attr("width", d.rectWidth).attr("height", d.rectHeight).attr("x", -d.rectWidth / 2).attr("y", -d.rectHeight / 2).attr("class", "node-shape"); }
      });

      node.each(function (d) {
        const s = d3.select(this);
        if (d.image) {
          const clipId = `clip-${d.id}`;
          if (d.depth === 0 || d.depth === 3) {
            const r = d.depth === 0 ? 50 : 30; defs.append("clipPath").attr("id", clipId).append("circle").attr("r", r);
            s.append("image").attr("xlink:href", `${d.image}?v=${cacheBust}`).attr("x", -r).attr("y", -r).attr("width", r * 2).attr("height", r * 2).attr("clip-path", `url(#${clipId})`).on("error", function () { d3.select(this).remove(); addNodeText(s, d); });
          } else {
            defs.append("clipPath").attr("id", clipId).append("rect").attr("width", d.rectWidth).attr("height", d.rectHeight).attr("x", -d.rectWidth / 2).attr("y", -d.rectHeight / 2).attr("rx", 4).attr("ry", 4);
            s.append("image").attr("xlink:href", `${d.image}?v=${cacheBust}`).attr("x", -d.rectWidth / 2).attr("y", -d.rectHeight / 2).attr("width", d.rectWidth).attr("height", d.rectHeight).attr("clip-path", `url(#${clipId})`).on("error", function () { d3.select(this).remove(); addNodeText(s, d); });
          }
        } else { addNodeText(s, d); }
        if (d.depth === 3) { s.append("text").attr("class", "node-label").attr("x", 0).attr("y", 42).attr("text-anchor", "middle").text(d.name); }
      });

      function addNodeText(sel, d) { if (d.depth !== 3) sel.append("text").attr("class", "node-inner-text").text(d.name); }

      node.on("mouseover", function (event, d) { const current = d3.select(this); const id = d.id; current.classed("highlighted", true); link.classed("highlighted", function (l) { if (l.source.id === id || l.target.id === id) { const connectedId = l.source.id === id ? l.target.id : l.source.id; g.selectAll('.node').filter(n => n.id === connectedId).classed("highlighted", true); return true; } return false; }); })
        .on("mouseout", function () { g.selectAll(".highlighted").classed("highlighted", false); });

      simulation.nodes(nodes).on("tick", ticked);
      simulation.force("link").links(links);

      // Initial Layout: Random scatter to let physics find the natural shape
      const rootNode = nodes.find(n => n.depth === 0);
      if (rootNode) { rootNode.fx = width / 2; rootNode.fy = height / 2; }

      nodes.forEach(d => {
        if (d.depth > 0) {
          d.x = width / 2 + (Math.random() - 0.5) * 200;
          d.y = height / 2 + (Math.random() - 0.5) * 200;
        }
      });

      warmupSimulation();
      simulation.alpha(1).restart();
      setTimeout(resetZoom, 2000);
      addEntranceAnimations();

      function warmupSimulation() {
        simulation.alpha(1);
        for (let i = 0; i < 50; i++) { simulation.tick(); }
      }

      function addEntranceAnimations() { link.style("opacity", 0).transition().delay((d, i) => 300 + i * 5).duration(800).style("opacity", 0.7); node.style("opacity", 0).attr("transform", d => `translate(${width / 2},${height / 2}) scale(0.1)`).transition().delay(d => d.depth * 200).duration(1000).style("opacity", 1).attrTween("transform", function (d) { return t => { const x = width / 2 + (d.x - width / 2) * t; const y = height / 2 + (d.y - height / 2) * t; const s = 0.1 + t * 0.9; return `translate(${x},${y}) scale(${s})`; }; }); }
      function resetZoom() { const rootNode = nodes.find(n => n.depth === 0); let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity; nodes.forEach(n => { minX = Math.min(minX, n.x); maxX = Math.max(maxX, n.x); minY = Math.min(minY, n.y); maxY = Math.max(maxY, n.y); }); const pad = 50; minX -= pad; maxX += pad; minY -= pad; maxY += pad; const gw = maxX - minX, gh = maxY - minY; const s = Math.min(width / gw, height / gh, 1) * 0.9; svg.transition().duration(800).call(zoom.transform, d3.zoomIdentity.translate(width / 2, height / 2).scale(s).translate(-rootNode.x, -rootNode.y)); }
      function ticked() { const rootNode = nodes.find(n => n.depth === 0); if (rootNode) { rootNode.x = width / 2; rootNode.y = height / 2; } link.attr("x1", d => d.source.x).attr("y1", d => d.source.y).attr("x2", d => d.target.x).attr("y2", d => d.target.y); g.selectAll('.node').attr("transform", d => `translate(${d.x},${d.y})`); }
      function dragstarted(event, d) { if (d.depth === 0) return; if (!event.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; }
      function dragged(event, d) { if (d.depth === 0) return; d.fx = event.x; d.fy = event.y; }
      function dragended(event, d) { if (d.depth === 0) return; if (!event.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; }

      function initZoomControls() {
        document.getElementById("zoom-in").addEventListener("click", () => { svg.transition().duration(300).call(zoom.scaleBy, 1.3); });
        document.getElementById("zoom-out").addEventListener("click", () => { svg.transition().duration(300).call(zoom.scaleBy, 0.7); });
        document.getElementById("reset").addEventListener("click", resetZoom);
      }
      initZoomControls();

      const searchInput = document.querySelector('.search-input');
      searchInput.addEventListener('input', applyFilters);

      function applyFilters() {
        const term = searchInput.value.toLowerCase();
        const matched = new Set();
        nodes.forEach(n => {
          const isLeaf = !n.children || n.children.length === 0;
          const nameMatch = n.name.toLowerCase().includes(term);

          if (term === '' && isLeaf || nameMatch) {
            if (isLeaf && (term === '' || nameMatch)) {
              matched.add(n);
              let a = n.parent; while (a) { matched.add(a); a = a.parent; }
            }
          }
        });
        if (term === '') { node.style('opacity', 1); link.style('opacity', 1); return; }
        node.style('opacity', d => matched.has(d) ? 1 : 0.15);
        link.style('opacity', d => matched.has(d.source) && matched.has(d.target) ? 1 : 0.05);
      }

      let popupEl = null;
      function openPopup(event, d) {
        if (!popupEl) {
          popupEl = document.createElement('div');
          popupEl.className = 'detail-popup';
          document.body.appendChild(popupEl);
          popupEl.addEventListener('click', (e) => e.stopPropagation());
          document.addEventListener('click', onDocClick);
        }

        const promoHtml = d.promoCode ? `
      <div class="promo-box">
        <div class="promo-label">PROMO CODE</div>
        <div class="promo-code">${d.promoCode}</div>
        <div class="promo-desc">${d.promoDescription}</div>
      </div>
    ` : '';

        const affiliateDisclaimer = d.isAffiliate ? `
      <div class="affiliate-disclaimer">
        * This link is an affiliate link. By using it, you support the project at no extra cost.
      </div>
    ` : '';

        const buttonText = d.isAffiliate ? 'Visit Service *' : 'Visit Service';

        popupEl.innerHTML = `
      <div class="header">
        ${d.image ? `<img src="${d.image}" alt="${d.name}">` : ''}
        <h3>${d.name}</h3>
      </div>
      ${d.description ? `<p>${d.description}</p>` : ''}
      <div class="meta">${d.region ? `REGION: ${d.region}` : ''}</div>
      ${promoHtml}
      <div class="actions">${d.link ? `<a class="btn" href="${d.link}" target="_blank" rel="noopener">${buttonText} <i class="ph ph-arrow-up-right"></i></a>` : ''}</div>
      ${affiliateDisclaimer}
    `;
      }
      function closePopup() { if (popupEl) { popupEl.remove(); popupEl = null; document.removeEventListener('click', onDocClick); } }
      function onDocClick() { closePopup(); }

      window.addEventListener('resize', () => { const nw = window.innerWidth; const nh = window.innerHeight; const rootNode = nodes.find(n => n.depth === 0); if (rootNode) { rootNode.fx = nw / 2; rootNode.fy = nh / 2; } simulation.force('center', d3.forceCenter(nw / 2, nh / 2)).alpha(0.3).restart(); });
    })();
  </script>
</body>

</html>